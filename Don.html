<!doctype html>
<html lang="de">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Herz-Checker – korrekt ausgerichtet, mit Debug-Overlay</title>
<style>
  :root{ --w: 256px; }
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;max-width:980px;margin:0 auto;padding:24px;line-height:1.45}
  h1{font-size:1.6rem;margin:0 0 0.5rem;}
  #wrap{display:grid;grid-template-columns:auto 1fr;gap:24px;align-items:start}
  .stage{position:relative;width:var(--w);height:var(--w)}
  #draw, #overlay{width:var(--w);height:var(--w);border-radius:10px}
  #draw{border:1px solid #ccc;background:#fff;touch-action:none}
  #overlay{position:absolute;left:0;top:0;pointer-events:none}
  .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin:12px 0;}
  button{padding:10px 16px;border-radius:8px;border:1px solid #bbb;background:#f6f6f6;cursor:pointer}
  button:active{transform:translateY(1px)}
  label{display:inline-flex;align-items:center;gap:6px}
  label span{min-width:8.8rem;display:inline-block}
  input[type=number]{width:6rem}
  #scores{font-variant-numeric:tabular-nums;margin-top:8px}
  #secret{display:none;margin-top:16px;padding:12px;border:1px dashed #8cbf26;border-radius:10px;background:#f7ffe8;}
  small.note{color:#555}
  .panel{padding:12px;border:1px solid #eee;border-radius:10px;background:#fafafa}
</style>

<h1>Mal’ ein Herz ❤️</h1>
<p>Zeichne ein Herz und klicke <b>Prüfen</b>. Das Overlay zeigt die beste gefundene Herzform.</p>

<div id="wrap">
  <div class="stage">
    <canvas id="draw" width="256" height="256"></canvas>
    <canvas id="overlay" width="256" height="256"></canvas>
  </div>

  <div>
    <div class="row">
      <button id="clear">Löschen</button>
      <button id="check">Prüfen</button>
    </div>

    <div class="panel">
      <div class="row">
        <label><span>Form-Schwelle</span>
          <input id="thrIoU" type="number" step="0.01" min="0" max="1" value="0.28">
        </label>
        <label><span>Symm.-Schwelle</span>
          <input id="thrSym" type="number" step="0.01" min="0" max="1" value="0.50">
        </label>
        <label title="Pixel-Toleranz (Abstand zur idealen Kante)">
          <span>Toleranz (px)</span>
          <input id="tolPix" type="number" step="1" min="1" max="32" value="6">
        </label>
      </div>
      <div class="row">
        <label title="rel. Kantenbreite der Herz-Schablone">
          <span>Kantenbreite</span>
          <input id="edgeFrac" type="number" step="0.01" min="0.05" max="0.4" value="0.18">
        </label>
        <label title="vertikale Streckung: >1 macht das Herz höher">
          <span>Vertikal-Faktor</span>
          <input id="aspectY" type="number" step="0.01" min="0.8" max="1.4" value="1.10">
        </label>
      </div>

      <hr>

      <div class="row">
        <label>
          <input id="dbgToggle" type="checkbox" checked>
          <span>Debug-Overlay anzeigen</span>
        </label>
        <label>
          <input id="dbgTol" type="checkbox" checked>
          <span>Toleranzband</span>
        </label>
      </div>
      <div class="row">
        <label><span>Farbe</span>
          <input id="dbgColor" type="color" value="#ff1744">
        </label>
        <label><span>Deckkraft</span>
          <input id="dbgAlpha" type="range" min="0" max="1" step="0.05" value="0.85">
          <output id="dbgAlphaOut">0.85</output>
        </label>
      </div>
    </div>

    <div id="scores">Bereit…</div>

    <div id="secret">
      ✅ Herz erkannt! <a id="secretLink" href="#" rel="nofollow noopener" target="_blank">Hier ist dein Link</a>
    </div>

    <hr>
    <small class="note">
      Das Overlay zeigt die <b>beste</b> gefundene Herzform (Skalierung, Drehung, Verschiebung). Das optionale
      Toleranzband markiert Pixel, die innerhalb deiner Toleranz zur idealen Kante liegen.
    </small>
  </div>
</div>

<script>
/* ===================== Einstellungen ===================== */
const SECRET_URL   = "https://example.com/dein-link";   // <— anpassen
let IOU_THRESHOLD  = 0.28;
let SYMM_THRESHOLD = 0.50;
let TOL_PIX        = 6;
let EDGE_FRAC      = 0.18;
let ASPECT_Y       = 1.10;

// getestete Skalen, Rotationen und Offsets
const SCALES  = [0.85, 0.95, 1.00, 1.05, 1.15];
const ROT_DEG = [-20, -12, -8, -4, 0, 4, 8, 12, 20];   // mehr Spielraum
const OFFSETS = [-6, -3, 0, 3, 6];

/* ===================== Canvas-Zeichnen ===================== */
const canvas = document.getElementById('draw');
const ctx = canvas.getContext('2d');
ctx.lineWidth = 16;
ctx.lineJoin = 'round';
ctx.lineCap = 'round';
ctx.strokeStyle = '#000';

const ov = document.getElementById('overlay');
const ovctx = ov.getContext('2d');

let drawing = false;
function pos(e){
  const r = canvas.getBoundingClientRect();
  const t = e.touches ? e.touches[0] : e;
  return { x: t.clientX - r.left, y: t.clientY - r.top };
}
function start(e){ drawing = true; const p = pos(e); ctx.beginPath(); ctx.moveTo(p.x,p.y); e.preventDefault(); }
function move(e){ if(!drawing) return; const p = pos(e); ctx.lineTo(p.x,p.y); ctx.stroke(); e.preventDefault(); }
function end(){ drawing = false; }

canvas.addEventListener('pointerdown', start);
canvas.addEventListener('pointermove', move);
canvas.addEventListener('pointerup', end);
canvas.addEventListener('pointerleave', end);
canvas.addEventListener('touchstart', start, {passive:false});
canvas.addEventListener('touchmove', move, {passive:false});
canvas.addEventListener('touchend', end);

document.getElementById('clear').onclick = () => {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ovctx.clearRect(0,0,ov.width,ov.height);
  document.getElementById('scores').textContent = 'Bereit…';
  document.getElementById('secret').style.display = 'none';
};

document.getElementById('secretLink').href = SECRET_URL;

// UI-Parameter binden
const $ = id => document.getElementById(id);
$('thrIoU').addEventListener('input', e => IOU_THRESHOLD  = parseFloat(e.target.value));
$('thrSym').addEventListener('input', e => SYMM_THRESHOLD = parseFloat(e.target.value));
$('tolPix').addEventListener('input', e => TOL_PIX        = parseFloat(e.target.value));
$('edgeFrac').addEventListener('input', e => EDGE_FRAC    = parseFloat(e.target.value));
$('aspectY').addEventListener('input', e => ASPECT_Y      = parseFloat(e.target.value));
$('dbgAlpha').addEventListener('input', e => $('dbgAlphaOut').textContent = Number(e.target.value).toFixed(2));
$('dbgAlphaOut').textContent = Number($('dbgAlpha').value).toFixed(2);

/* ============ Bild zu Binärmaske (1 = Strich) ============ */
function canvasToMask(cnv){
  const w = cnv.width, h = cnv.height;
  const data = cnv.getContext('2d').getImageData(0,0,w,h).data;
  const mask = new Uint8Array(w*h);
  let minX=w, minY=h, maxX=-1, maxY=-1, count=0;

  for(let y=0; y<h; y++){
    for(let x=0; x<w; x++){
      const i = (y*w + x)*4;
      const a = data[i+3];
      const r = data[i], g = data[i+1], b = data[i+2];
      const lum = 0.2126*r + 0.7152*g + 0.0722*b;
      const dark = lum < 200;
      if(a>10 && dark){
        mask[y*w + x] = 1;
        count++;
        if(x<minX) minX=x; if(x>maxX) maxX=x;
        if(y<minY) minY=y; if(y>maxY) maxY=y;
      }
    }
  }
  if(count===0) return {mask, w, h, bbox:null, count:0};

  // leichte Dilatation (3x3)
  const dil = mask.slice();
  for(let y=1;y<h-1;y++){
    for(let x=1;x<w-1;x++){
      let s=0;
      for(let dy=-1;dy<=1;dy++) for(let dx=-1;dx<=1;dx++) s+=mask[(y+dy)*w + (x+dx)];
      if(s>=2) dil[y*w+x]=1;
    }
  }
  return {mask:dil, w, h, bbox:{minX,minY,maxX,maxY}, count};
}

/* ============ Symmetrie (IoU mit gespiegelter Maske) ============ */
function symmetryScore(mask, w, h){
  let sumX=0, cnt=0;
  for(let i=0;i<w*h;i++) if(mask[i]){ sumX += (i%w); cnt++; }
  if(cnt===0) return 0;
  const cx = sumX/cnt;

  let inter=0, uni=0;
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      const a = mask[y*w+x];
      const mx = Math.round(2*cx - x);
      let b = 0;
      if(mx>=0 && mx<w) b = mask[y*w+mx];
      if(a|b) uni++;
      if(a&b) inter++;
    }
  }
  return uni ? inter/uni : 0;
}

/* ============ Abstandstransform (Chamfer) ============ */
function edtFromMask(mask, w, h){
  const INF = 1e9, d = new Float32Array(w*h);
  for(let i=0;i<w*h;i++) d[i] = mask[i] ? 0 : INF;

  const c1 = 1.0, cD = Math.SQRT2;
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      const i = y*w+x;
      let v = d[i];
      if(x>0)          v = Math.min(v, d[i-1] + c1);
      if(y>0)          v = Math.min(v, d[i-w] + c1);
      if(x>0 && y>0)   v = Math.min(v, d[i-w-1] + cD);
      if(x<w-1 && y>0) v = Math.min(v, d[i-w+1] + cD);
      d[i] = v;
    }
  }
  for(let y=h-1;y>=0;y--){
    for(let x=w-1;x>=0;x--){
      const i = y*w+x;
      let v = d[i];
      if(x<w-1)          v = Math.min(v, d[i+1] + c1);
      if(y<h-1)          v = Math.min(v, d[i+w] + c1);
      if(x<w-1 && y<h-1) v = Math.min(v, d[i+w+1] + cD);
      if(x>0 && y<h-1)   v = Math.min(v, d[i+w-1] + cD);
      d[i] = v;
    }
  }
  return d;
}

/* ============ Herz füllen (implizite Gleichung, y nach OBEN) ============ */
function fillHeartMask(arr, W,H, offX, offY, boxW, boxH, scale, rotRad=0){
  // (x^2 + y^2 - r^2)^3 - r * x^2 * y^3 <= 0
  // Wichtig: Hier ist y nach OBEN positiv. Wir invertieren Canvas-y.
  const r = 1.0;
  const cos = Math.cos(rotRad), sin = Math.sin(rotRad);

  for (let y = 0; y < boxH; y++) {
    for (let x = 0; x < boxW; x++) {
      const gx = offX + x, gy = offY + y;
      if (gx < 0 || gy < 0 || gx >= W || gy >= H) continue;

      // Normierung: x in [-1,1]; y in [-1,1] mit y=+1 oben, -1 unten
      let nx = (x / boxW) * 2 - 1;
      let ny = 1 - (y / boxH) * 2;

      // CCW-Rotation im mathematischen System (y nach oben)
      const rx =  cos * nx - sin * ny;
      const ry =  sin * nx + cos * ny;

      // Skalierung + vertikale Streckung
      nx = rx / scale;
      ny = (ry / scale) * ASPECT_Y;

      const v = Math.pow(nx*nx + ny*ny - r*r, 3) - r * nx*nx * ny*ny*ny;
      if (v <= 0) arr[gy * W + gx] = 1;
    }
  }
}

/* ============ Herz-Kante (dicker Ring) ============ */
function heartEdgeMask(W,H,bbox,scale,edgeFrac,rotRad,dx=0,dy=0){
  const {minX,minY,maxX,maxY} = bbox;
  const boxW = Math.max(1, maxX-minX+1);
  const boxH = Math.max(1, maxY-minY+1);

  const big = new Uint8Array(W*H);
  const small = new Uint8Array(W*H);

  fillHeartMask(big,   W,H, minX+dx, minY+dy, boxW, boxH, scale, rotRad);
  fillHeartMask(small, W,H, minX+dx, minY+dy, boxW, boxH, scale*(1-edgeFrac), rotRad);

  const edge = new Uint8Array(W*H);
  let edgeCount = 0;
  for(let i=0;i<W*H;i++){
    const e = big[i] && !small[i] ? 1 : 0;
    edge[i]=e; edgeCount+=e;
  }
  return {edge, edgeCount};
}

/* ============ Dice-Koeffizient ============ */
function diceCoeff(a,b){
  let inter=0, sa=0, sb=0;
  for(let i=0;i<a.length;i++){
    if(a[i]) sa++;
    if(b[i]) sb++;
    if(a[i] & b[i]) inter++;
  }
  return (sa+sb) ? (2*inter)/(sa+sb) : 0;
}

/* ============ Hauptvergleich ============ */
function matchScore(drawMask, W,H, bbox){
  if(!bbox) return {score:0, best:{scale:1,rot:0,dx:0,dy:0}, coverE:0, coverS:0, dice:0};

  const distS = edtFromMask(drawMask, W,H);
  let best = {score:0, best:{scale:1,rot:0,dx:0,dy:0}, coverE:0, coverS:0, dice:0};

  for(const s of SCALES){
    for(const deg of ROT_DEG){
      const rot = deg * Math.PI/180;
      for(const dx of OFFSETS){
        for(const dy of OFFSETS){
          const {edge, edgeCount} = heartEdgeMask(W,H,bbox,s,EDGE_FRAC,rot,dx,dy);
          if(edgeCount===0) continue;

          // Edge→Stroke
          let hitE = 0;
          for(let i=0;i<W*H;i++){
            if(edge[i] && distS[i] <= TOL_PIX) hitE++;
          }
          const coverE = hitE / edgeCount;

          // Stroke→Edge
          const distE = edtFromMask(edge, W,H);
          let drawn=0, hitS=0;
          for(let i=0;i<W*H;i++){
            if(drawMask[i]){
              drawn++;
              if(distE[i] <= TOL_PIX) hitS++;
            }
          }
          const coverS = drawn ? hitS / drawn : 0;

          // Dice der tolerierten Masken
          const tolE = new Uint8Array(W*H);
          const tolS = new Uint8Array(W*H);
          for(let i=0;i<W*H;i++){
            if(distE[i] <= TOL_PIX) tolE[i]=1;
            if(distS[i] <= TOL_PIX) tolS[i]=1;
          }
          const dice = diceCoeff(tolE, tolS);

          const minCov = Math.min(coverE, coverS);
          const score = 0.5*minCov + 0.5*dice;

          if(score > best.score){
            best = {score, best:{scale:s,rot:deg,dx,dy}, coverE, coverS, dice, edge, distE};
          }
        }
      }
    }
  }
  return best;
}

/* ============ Debug-Overlay zeichnen ============ */
function hexToRGBA(hex, alpha){
  const v = hex.startsWith('#') ? hex.slice(1) : hex;
  const r = parseInt(v.slice(0,2),16);
  const g = parseInt(v.slice(2,4),16);
  const b = parseInt(v.slice(4,6),16);
  return {r,g,b,a:Math.max(0,Math.min(1,alpha))};
}

function renderOverlay(W,H, match, showTol, colorHex, alpha){
  ovctx.clearRect(0,0,W,H);
  if(!document.getElementById('dbgToggle').checked || !match.edge){ return; }

  const {r,g,b,a} = hexToRGBA(colorHex, alpha);
  const img = ovctx.createImageData(W,H);
  const data = img.data;

  // Toleranzband
  if(showTol && match.distE){
    const tolA = a * 0.35;
    for(let i=0;i<W*H;i++){
      if(match.distE[i] <= TOL_PIX){
        const j = i*4;
        data[j]   = r;
        data[j+1] = g;
        data[j+2] = b;
        data[j+3] = Math.round(tolA*255);
      }
    }
  }

  // Kante
  for(let i=0;i<W*H;i++){
    if(match.edge[i]){
      const j = i*4;
      data[j]   = r;
      data[j+1] = g;
      data[j+2] = b;
      data[j+3] = Math.round(a*255);
    }
  }

  ovctx.putImageData(img, 0, 0);
}

/* ===================== Prüfen-Button ===================== */
document.getElementById('check').onclick = () => {
  const {mask,w,h,bbox} = canvasToMask(canvas);
  const symm = symmetryScore(mask,w,h);

  const match = matchScore(mask,w,h,bbox);
  const isHeart = match.score >= IOU_THRESHOLD && symm >= SYMM_THRESHOLD;

  const pct = x => (x*100).toFixed(1)+'%';
  const b = match.best;
  document.getElementById('scores').innerHTML =
    `Score: <b>${pct(match.score)}</b> &nbsp; ` +
    `Edge→Stroke: ${pct(match.coverE)} &nbsp; ` +
    `Stroke→Edge: ${pct(match.coverS)} &nbsp; ` +
    `Dice: ${pct(match.dice)} &nbsp; ` +
    `| Symmetrie: <b>${pct(symm)}</b> &nbsp; ` +
    `| Scale ${b.scale.toFixed(2)} · Rot ${b.rot}° · dx ${b.dx} · dy ${b.dy}`;

  document.getElementById('secret').style.display = isHeart ? 'block' : 'none';

  renderOverlay(
    w, h,
    match,
    document.getElementById('dbgTol').checked,
    document.getElementById('dbgColor').value,
    parseFloat(document.getElementById('dbgAlpha').value)
  );
};
</script>
</html>
