<!doctype html>
<html lang="de">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Herz-Checker – Canvas ohne ML</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;max-width:780px;margin:0 auto;padding:24px;}
  h1{font-size:1.6rem;margin:0 0 0.5rem;}
  #draw{border:1px solid #ccc;border-radius:8px;touch-action:none;background:#fff;}
  .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin:12px 0;}
  button{padding:10px 16px;border-radius:6px;border:1px solid #bbb;background:#f6f6f6;cursor:pointer}
  button:active{transform:translateY(1px)}
  label span{display:inline-block;width:7.5rem}
  #scores{font-variant-numeric:tabular-nums}
  #secret{display:none;margin-top:16px;padding:12px;border:1px dashed #8cbf26;border-radius:8px;background:#f7ffe8;}
  small.note{color:#555}
</style>

<h1>Mal’ ein Herz ❤️</h1>
<p>Drücke <b>Prüfen</b>. Wenn die Zeichnung wie ein Herz aussieht, erscheint der Link.</p>

<canvas id="draw" width="224" height="224"></canvas>

<div class="row">
  <button id="clear">Löschen</button>
  <button id="check">Prüfen</button>

  <label><span>Schwelle Form</span>
    <input id="thrIoU" type="number" step="0.01" min="0" max="1" value="0.35" style="width:5.5rem">
  </label>
  <label><span>Schwelle Symm.</span>
    <input id="thrSym" type="number" step="0.01" min="0" max="1" value="0.60" style="width:5.5rem">
  </label>
</div>

<div id="scores">Bereit…</div>

<div id="secret">
  ✅ Herz erkannt! <a id="secretLink" href="#" rel="nofollow noopener" target="_blank">Hier ist dein Link</a>
</div>

<hr>
<small class="note">
  Tipp: Zeichne ein deutliches, in sich geschlossenes Herz mit kräftigen Linien. Der Algorithmus vergleicht deine Linien mit einem Herz-Umriss
  und prüft die Links-Rechts-Symmetrie. Sehr schiefe, offene oder stark dekorierte Formen können abgelehnt werden.
</small>

<script>
/*** Einstellungen ***/
const SECRET_URL = "https://example.com/dein-link";  // <— anpassen
let IOU_THRESHOLD   = 0.35; // erforderliche Überdeckung mit Herz-Umriss
let SYMM_THRESHOLD  = 0.60; // erforderliche Links/Rechts-Symmetrie
const EDGE_FRAC     = 0.10; // Dicke des Herz-Umrisses relativ zur Größe
const SCALES        = [0.80, 0.90, 1.00, 1.10, 1.20]; // getestete Herzgrößen

// Canvas-Zeichnen
const canvas = document.getElementById('draw');
const ctx = canvas.getContext('2d');
ctx.lineWidth = 14;
ctx.lineJoin = 'round';
ctx.lineCap = 'round';
ctx.strokeStyle = '#000';

let drawing = false;
function pos(e){
  const r = canvas.getBoundingClientRect();
  const t = e.touches ? e.touches[0] : e;
  return { x: t.clientX - r.left, y: t.clientY - r.top };
}
function start(e){ drawing = true; const p = pos(e); ctx.beginPath(); ctx.moveTo(p.x,p.y); e.preventDefault(); }
function move(e){ if(!drawing) return; const p = pos(e); ctx.lineTo(p.x,p.y); ctx.stroke(); e.preventDefault(); }
function end(){ drawing = false; }

canvas.addEventListener('pointerdown', start);
canvas.addEventListener('pointermove', move);
canvas.addEventListener('pointerup', end);
canvas.addEventListener('pointerleave', end);
canvas.addEventListener('touchstart', start, {passive:false});
canvas.addEventListener('touchmove', move, {passive:false});
canvas.addEventListener('touchend', end);

document.getElementById('clear').onclick = () => {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  document.getElementById('scores').textContent = 'Bereit…';
  document.getElementById('secret').style.display = 'none';
};

document.getElementById('thrIoU').addEventListener('input', e => IOU_THRESHOLD = parseFloat(e.target.value));
document.getElementById('thrSym').addEventListener('input', e => SYMM_THRESHOLD = parseFloat(e.target.value));
document.getElementById('secretLink').href = SECRET_URL;

/*** Bilddaten -> Binärmaske (1 = Strich) ***/
function canvasToMask(cnv){
  const w = cnv.width, h = cnv.height;
  const data = cnv.getContext('2d').getImageData(0,0,w,h).data;
  const mask = new Uint8Array(w*h);
  let minX=w, minY=h, maxX=-1, maxY=-1, count=0;

  for(let y=0; y<h; y++){
    for(let x=0; x<w; x++){
      const i = (y*w + x)*4;
      const a = data[i+3];
      const r = data[i], g = data[i+1], b = data[i+2];
      // als Strich zählen, wenn sichtbar und dunkel
      const dark = (0.2126*r + 0.7152*g + 0.0722*b) < 200;
      if(a>10 && dark){
        mask[y*w + x] = 1;
        count++;
        if(x<minX) minX=x; if(x>maxX) maxX=x;
        if(y<minY) minY=y; if(y>maxY) maxY=y;
      }
    }
  }
  if(count===0) return {mask, w, h, bbox:null, count:0};
  // kleine Ausdehnung (3x3), um Lücken zu schließen
  const dil = mask.slice();
  for(let y=1;y<h-1;y++){
    for(let x=1;x<w-1;x++){
      let s=0;
      for(let dy=-1;dy<=1;dy++) for(let dx=-1;dx<=1;dx++) s+=mask[(y+dy)*w + (x+dx)];
      if(s>=2) dil[y*w+x]=1;
    }
  }
  return {mask:dil, w, h, bbox:{minX,minY,maxX,maxY}, count};
}

/*** Spiegelsymmetrie (IoU mit horizontal gespiegelter Maske) ***/
function symmetryScore(mask, w, h){
  // Schwerpunkt als Symmetrieachse
  let sumX=0, cnt=0;
  for(let y=0;y<h;y++) for(let x=0;x<w;x++){
    if(mask[y*w+x]){ sumX+=x; cnt++; }
  }
  if(cnt===0) return 0;
  const cx = sumX/cnt;
  let inter=0, uni=0;
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      const a = mask[y*w+x];
      const mx = Math.round(2*cx - x);
      let b = 0;
      if(mx>=0 && mx<w) b = mask[y*w+mx];
      if(a|b) uni++;
      if(a&b) inter++;
    }
  }
  return uni? inter/uni : 0;
}

/*** Herzgefüllte Maske in Zielrechteck schreiben ***/
function fillHeartMask(arr, W, H, offX, offY, boxW, boxH, scale){
  // Herzgleichung im [-1,1]-Koordinatensystem
  const r = 1.0;
  // leichte vertikale Streckung für „klassische“ Herzform
  const aspectY = 1.1;

  for(let y=0; y<boxH; y++){
    for(let x=0; x<boxW; x++){
      const gx = offX + x;
      const gy = offY + y;
      if(gx<0||gy<0||gx>=W||gy>=H) continue;

      // Normierung in [-1,1]
      const nx = ((x/boxW)*2 - 1) / scale;
      const ny = (((y/boxH)*2 - 1) / scale) * aspectY;

      const v = Math.pow(nx*nx + ny*ny - r*r, 3) - r * nx*nx * ny*ny*ny;
      if(v <= 0){
        arr[gy*W + gx] = 1;
      }
    }
  }
}

/*** Herz-Umriss (Kante) aus zwei gefüllten Herzen (groß - klein) ***/
function heartEdgeMask(W,H,bbox,scale,edgeFrac){
  const {minX,minY,maxX,maxY} = bbox;
  const boxW = Math.max(1, maxX-minX+1);
  const boxH = Math.max(1, maxY-minY+1);

  const big = new Uint8Array(W*H);
  const small = new Uint8Array(W*H);

  fillHeartMask(big,   W,H, minX, minY, boxW, boxH, scale);
  fillHeartMask(small, W,H, minX, minY, boxW, boxH, scale*(1-edgeFrac));

  const edge = new Uint8Array(W*H);
  let edgeCount = 0;
  for(let i=0;i<W*H;i++){
    const e = big[i] && !small[i] ? 1 : 0;
    edge[i]=e; edgeCount+=e;
  }
  return {edge, edgeCount};
}

/*** Abgleich: Überdeckung zwischen Zeichnungs-Strichen und Herz-Umriss ***/
function matchScore(drawMask, W,H, bbox){
  if(!bbox) return {score:0, bestScale:1, edgeHit:0, edgeTotal:1, extraPenalty:1};

  let best = {score:0, bestScale:1, edgeHit:0, edgeTotal:1, extraPenalty:1};

  // Anzahl gezeichneter Pixel (für „Übermalen“-Penalty)
  let drawn=0; for(let i=0;i<W*H;i++) if(drawMask[i]) drawn++;

  for(const s of SCALES){
    const {edge, edgeCount} = heartEdgeMask(W,H,bbox,s,EDGE_FRAC);
    if(edgeCount===0) continue;

    let hit=0;
    for(let i=0;i<W*H;i++){
      if(edge[i] & drawMask[i]) hit++;
    }
    const edgeCover = hit / edgeCount;      // Anteil der Herz-Kante, die getroffen wurde
    const drawingUse = drawn ? hit / drawn : 0; // Anteil deiner Striche, die auf der Herz-Kante liegen

    // finaler Score: konservativ das Minimum der beiden Anteile
    const score = Math.min(edgeCover, drawingUse);

    if(score > best.score){
      best = {score, bestScale:s, edgeHit:hit, edgeTotal:edgeCount, extraPenalty:drawingUse};
    }
  }
  return best;
}

document.getElementById('check').onclick = () => {
  const {mask,w,h,bbox} = canvasToMask(canvas);
  const symm = symmetryScore(mask,w,h);

  const match = matchScore(mask,w,h,bbox);
  const isHeart = match.score >= IOU_THRESHOLD && symm >= SYMM_THRESHOLD;

  const pct = x => (x*100).toFixed(1)+'%';
  const boxTxt = bbox
    ? `BBox ${bbox.minX},${bbox.minY}–${bbox.maxX},${bbox.maxY}`
    : 'keine Striche';

  document.getElementById('scores').innerHTML =
    `Form-Score: <b>${pct(match.score)}</b> &nbsp; ` +
    `(Kanten-Treffer ${pct(match.edgeHit/(match.edgeTotal||1))}, ` +
    `Strich-Nutzung ${pct(match.extraPenalty)}) &nbsp; ` +
    `| Symmetrie: <b>${pct(symm)}</b> &nbsp; ` +
    `| Scale: ${match.bestScale.toFixed(2)} &nbsp; ` +
    `| ${boxTxt}`;

  document.getElementById('secret').style.display = isHeart ? 'block' : 'none';
};
</script>
</html>
